//------------------------------------------------------------------------------
// main.c
//------------------------------------------------------------------------------
// Copyright (C) 2005 Silicon Laboratories, Inc.
//
// Date: 04/13/08 06:24:26
// Target: C8051F34x 
//
// Description:
//    This file contains the main routine, MCU initialization code, and
//    callback functions used by the TCP/IP Library.
//
// Generated by TCP/IP Configuration Wizard Version 3.23
//
#include "mn_userconst.h"                      // TCP/IP Library Constants
#include "mn_stackconst.h"                     // TCP/IP Library Constants
#include "mn_errs.h"                           // Library Error Codes
#include "mn_defs.h"                           // Library Type definitions
#include "mn_funcs.h"                          // Library Function Prototypes
#include "VFILE_DIR\index.h"
#include <c8051F340.h>                         // Device-specific SFR Definitions
#include <stdio.h>
#include <string.h>
#include "soft_i2c.h"

//------------------------------------------------------------------------------
// Function Prototypes
//------------------------------------------------------------------------------



// Initialization Routines
void PORT_Init (void);
void SYSCLK_Init (void);
void EMIF_Init(void);
int establish_network_connection();
//void get_data(PSOCKET_INFO socket_ptr);
void wol(PSOCKET_INFO socket_ptr);
void set(PSOCKET_INFO socket_ptr);
void get_hora(PSOCKET_INFO socket_ptr);


//Funciones de fecha
struct fecha
{
	int hora, min, sec;
	char valid;
//	char day, date, month, year;
};

struct fecha gethora_web(byte ip[4]);
struct fecha gethora_i2c();
void sethora_i2c(struct fecha f);

sbit SW1 = P1^1;
sbit SW2 = P1^2;
sbit LED0 = P1^3;
sbit LED1 = P1^4;

sbit RELE = P0^1;

sbit TRIAC1 = P0^7;
sbit TRIAC2 = P0^4;
sbit TRIAC3 = P0^2;
sbit TRIAC4 = P0^0;
//sbit TRIAC5 = P0^3;
sbit TRIAC6 = P0^5;

sbit DETFASE = P0^6;

sfr16  TMR2RL      =  0xCA;



struct fecha now={23,00,10};

int regtriac[4]={100,100,100,100};
int st_triac[6]={0,0,0,0,0,0};
int low=0, high=0;
bit st_rele=0;

bit power_mising=0;

xdata byte html_buffer[256];
byte dest_mac[6]={0x00,0x11,0x2F,0x91,0xE3,0x74};	// dir mac del wol
byte dest_ip[4]={192,168,1,1};						// ip del servidor web para hora
//-----------------------------------------------------------------------------
// Main Routine
//-----------------------------------------------------------------------------

char get_celsius()
{
	return read_register(TC74A0,0);
}

void main(void)
{
   int retval;
	char c,d;

   // Disable watchdog timer
   PCA0MD = 0x00;

   // Initialize the MCU
   PORT_Init();
   SYSCLK_Init();
   EMIF_Init();


	TMR2CN    = 0x04;
 	IE        |= 0xA0;
	TMR2RL=-100*4;
	IP|=0x20;

   while(1)
   {
      // Initialize the TCP/IP stack. 
      if (mn_init() < 0)
      {
         // If code execution enters this while(1) loop, the stack failed to initialize.
         // Verify that all boards are connected and powered properly.
         while(1);
      }

      // Connect to the network
      establish_network_connection();
     	
	  
	  now=gethora_i2c();

      // Add web page to virtual file system.
      // The main page MUST be called index.htm or index.html.
      mn_vf_set_entry((byte *)"index.html", INDEX_SIZE, index_html, VF_PTYPE_FLASH);

	  // Add CGI Script to Virtual File System
	  mn_pf_set_entry((byte*)"wol",wol);
	  mn_pf_set_entry((byte*)"get_hora",get_hora);
	  mn_pf_set_entry((byte*)"set",set);

      // Start the Application Layer Services
      // If this routine exits, check the return value for an error code.
      retval = mn_server();

   }
}

void sethora_i2c(struct fecha f)
{
	char s,m,h;
	s=(f.sec/10)<<4|(f.sec%10);
	m=(f.min/10)<<4|(f.min%10);
	h=(f.hora/10)*16|(f.hora%10);
	write_register(DS1307,0,s);
	write_register(DS1307,1,m);
	write_register(DS1307,2,h);
}

struct fecha gethora_i2c()
{
	struct fecha f;
	char h,m,s;
	s=read_register(DS1307,0);
	m=read_register(DS1307,1);
	h=read_register(DS1307,2);
	f.sec= (s&0xf)+(s>>4)*10;
	f.min= (m&0xf)+(m>>4)*10;
	f.hora= (h&0xf)+(h>>4)*10;
	return f;


}
void Timer2_handler() interrupt 5
{
   static int tics=0;
   static bit old_fase=0;
   static int cruces=0;
   
   if(old_fase!=DETFASE)
   {
   		old_fase=DETFASE;
		if(DETFASE==0)
			tics=low;
		else
			tics=high;
		cruces++;
   }
   else
   		tics++;

RELE=st_rele;
TRIAC6=st_triac[5];
//TRIAC5=st_triac[4];

if(!st_triac[3])
	TRIAC4=0;
else if(regtriac[3]>100)
	TRIAC4=1;
else if(tics==100-regtriac[3])
	TRIAC4=1;
else
	TRIAC4=0;

if(!st_triac[2])
	TRIAC3=0;
else if(regtriac[2]>100)
	TRIAC3=1;
else if(tics==100-regtriac[2])
	TRIAC3=1;
else
	TRIAC3=0;

if(!st_triac[1])
	TRIAC2=0;
else if(regtriac[1]>100)
	TRIAC2=1;
else if(tics==100-regtriac[1])
	TRIAC2=1;
else
	TRIAC2=0;

if(!st_triac[0])
	TRIAC1=0;
else if(regtriac[0]>100)
	TRIAC1=1;
else if(tics==100-regtriac[0])
	TRIAC1=1;
else
	TRIAC1=0;




if(cruces==100||tics>10019)
	{
	if(tics>10019)
		{
		power_mising=1;
		tics=0;
		}
	else
		{
		power_mising=0;
		cruces=0;
		}
	/*
	now.sec++;	
   	if(now.sec>=60)
		{now.sec=0;now.min++;}
	if(now.min>=60)
		{now.min=0;now.hora++;}
	if(now.hora>=24)
		{now.hora=0;}
	*/
	}

   TF2H=0;

}

void wakeup(byte mac[6])
{
	byte dest_ip[4]={255,255,255,255};
		byte magic_pkg[102]={0xff,0xff,0xff,0xff,0xff,0xff};
		 SCHAR rafa;

		int i;
		for(i=0;i<16*6;i++)
			magic_pkg[i+6]=mac[i%6];
     
	  rafa=mn_open(dest_ip, 7890, 80,NO_OPEN, PROTO_UDP, STD_TYPE,html_buffer,256);
	  mn_send(rafa, magic_pkg,102);
	  mn_close(rafa);
}

struct fecha gethora_web(byte dest_ip[4])
{
    char qry[]="GET / HTTP1.1\r\n\r\n";
	int status;
	int pos=0,i;
	SCHAR rafa;
	struct fecha f;
	
	f.valid=0;
	for(i=0;i<256;i++)html_buffer[i]=0;
	
	rafa=mn_open(dest_ip, 1234, 80,ACTIVE_OPEN, PROTO_TCP, STD_TYPE,html_buffer,256);
	mn_send(rafa, qry,strlen(qry));
	status=mn_recv_wait(rafa, html_buffer,256,20000);
	mn_close(rafa);
	for(pos=0;html_buffer[pos]!=0;pos++)
		if(!strncmp(&html_buffer[pos],"GMT",3))
			break;

	if(html_buffer[pos]!=0)
		{
		sscanf(&html_buffer[pos-9],"%d:%d:%d",&f.hora,&f.min,&f.sec);
		f.valid=1;		
		}
	return f;
	

}
byte hex2dec(byte c)
{
	if(c>='0'&&c<='9')
		return c-'0';
	else if(c>='a'&&c<='f')
		return c-'a'+0xa;
	else
		return c-'A'+0xa;
}



SCHAR callback_app_server_idle(PSOCKET_INFO *psocket_ptr)
{

   // Put your code here.

   // If the link goes invalid, exit mn_server().
   if(link_lost)
      return (NEED_TO_EXIT);
	if(!SW1)
		{
		now=gethora_web(dest_ip);
	  	if(now.valid)
	  		sethora_i2c(now);

		}
		//wakeup(dest_mac);
   now=gethora_i2c();

   psocket_ptr = psocket_ptr; // This statment prevents compiler warning.
   return (0);
}

void wol(PSOCKET_INFO socket_ptr)
{
	// Insert application code here.

	byte msg_buff1[52];
	int status1;
	byte mac[6];
	int i,j;

	status1 = mn_http_find_value (BODYptr,(byte*)"mac", msg_buff1);

	if(status1)
	{
		// Write the HTML code to a buffer.
		//sscanf( msg_buff1, "%x:%x:%x:%x:%x:%x",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
		for(i=0,j=0;i<6;i++)
		{
			mac[i]=hex2dec(msg_buff1[j])<<4;
			mac[i]|=hex2dec(msg_buff1[j+1]);
			if(msg_buff1[j+2]==':')
				j+=3;
			else
				j+=2;
		}

		
		wakeup(mac);
		// Fill the socket with data to send.
		sprintf(html_buffer, "<HTML>OK</HTML>");
		socket_ptr->send_ptr = html_buffer;
		socket_ptr->send_len = strlen(html_buffer);
		// Return from the CGI script
		return;
	}

}

// Definition:
/*
void get_data(PSOCKET_INFO socket_ptr)
{
	// Insert application code here.

	byte msg_buff1[52];
	byte msg_buff2[52];
	int status1;
	static int ambient_light=0;



	// Search for the “type” field and store the
	// result in <msg_buff1>.
	status1 = mn_http_find_value (BODYptr,(byte*)"type", msg_buff1);

	// Search for the “setbgcolor” field
	// and store the result in <msg_buff2>.
	//status2 = mn_http_find_value (BODYptr,(byte*)"setbgcolor",msg_buff2);

	// Check status1 and status2 to determine if
	// msg_buff1 and msg_buff2 are valid.
	if(status1)
	{
		// Write the HTML code to a buffer.
		sprintf( html_buffer, "<HTML>%i</HTML>",ambient_light++);

		// Fill the socket with data to send.
		socket_ptr->send_ptr = html_buffer;
		socket_ptr->send_len = strlen(html_buffer);
		// Return from the CGI script
		return;
	}

}
*/
void set(PSOCKET_INFO socket_ptr)
{
	// Insert application code here.
	char *sets[]={"time","triac1","triac2","triac3","triac4","triac5","triac6","rele","low","high"};
	const int maxsets=9;
	int i;
	byte msg_buff1[52];

	int status1, status2;

	status2=0;

	for(i=0;i<maxsets;i++)
	{
		// Search for the “type” field and store the
		// result in <msg_buff1>.
		status1 = mn_http_find_value (BODYptr,(byte*)sets[i], msg_buff1);

		// Check status1 and status2 to determine if
		// msg_buff1 and msg_buff2 are valid.
	  if(status1)
	  {
	  	if(i==0)
		{
			sscanf( msg_buff1, "%d:%d:%d",&now.hora,&now.min,&now.sec);
		}
		else if(i==7)
		{
			if(!strcmp(msg_buff1,"on"))
				st_rele=1;
			else if(!strcmp(msg_buff1,"off"))
				st_rele=0;
		}
		else if(i==8)
		{
			sscanf(msg_buff1,"%d",&low);
		}
		else if(i==9)
		{
			sscanf(msg_buff1,"%d",&high);
		}
		else
		{
			int j=i-1;
			if(!strcmp(msg_buff1,"on"))
				st_triac[j]=1;
			else if(!strcmp(msg_buff1,"off"))
				st_triac[j]=0;
			else if (j<4)
				{
				int tmp;
				sscanf(msg_buff1,"%d",&tmp);
				regtriac[j]=tmp;
				st_triac[j]=1;
				}
		}
		status2=1;
	   }
	}

	if(status2)
	{
		
		// Fill the socket with data to send.
		sprintf(html_buffer, "<HTML>OK</HTML>");
		socket_ptr->send_ptr = html_buffer;
		socket_ptr->send_len = strlen(html_buffer);
		// Return from the CGI script
		return;
	}

}
void get_hora(PSOCKET_INFO socket_ptr)
{
	// Insert application code here.

	int temp=get_celsius();
	// Write the HTML code to a buffer.
	sprintf( html_buffer, "<HTML><meta http-equiv=\"refresh\" content=\"1\">%2.2d:%2.2d:%2.2d   Temperature: %d ºC\tPower: %s</HTML>",now.hora,now.min,now.sec,temp,(power_mising?"OFF":"ON"));

	// Fill the socket with data to send.
	socket_ptr->send_ptr = html_buffer;
	socket_ptr->send_len = strlen(html_buffer);
	// Return from the CGI script
	return;
	
}

//-----------------------------------------------------------------------------
// establish_network_connection
//-----------------------------------------------------------------------------
//
// This function calls mn_ether_init() to initialize the CP2200 and attach to
// the network.
//
// If there is a network connection, the function returns 1.
//
// In the call to mn_ether_init(), NUM_AUTONEG_ATTEMPTS is set to 0, so the
// function will not return until it successfully auto-negotiates.
//
// mn_ether_init() will not be a blocking call if NUM_AUTONEG_ATTEMPTS is set
// to a value greater than 0.
//
int establish_network_connection()
{
   int retval;

   do
   {
      // mn_ether_init() initializes the Ethernet controller.
      // AUTO_NEG indicates that the controller will auto-negotiate.
      retval = mn_ether_init(AUTO_NEG, 0, 0);

      // If there is no link, poll link_status until it sets or the
      // CP2200 resets and then call mn_ether_init() again.
      if (retval == LINK_FAIL)
      {
         while(!link_status && !ether_reset);
      }

      // If retval is less than zero and is not LINK_FAIL, there is a 
      // hardware error.
      else if (retval < 0)
      {
         // Verify that the Ethernet controller is connected and powered properly.
         // Verity that the EMIF has been configured at a speed compatible with the
         //    Ethernet controller.
         while(1);
      }

   }while(retval < 0);

   return (1);

}


//-----------------------------------------------------------------------------
// Initialization Routines
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// PORT_Init
//-----------------------------------------------------------------------------
//
// Configure the Interrupts, Crossbar and GPIO ports
//
void PORT_Init (void)
{

   IT01CF = 0x03;                      // Enable Interrupt 0 on P0.3
   TCON &= ~0x01;                      // Make /INT0 level triggered

   XBR0    = 0x01;                     // Enable UART on P0.4(TX) and P0.5(RX)
   XBR1    = 0xC0;                     // Enable crossbar and disable
                                       // weak pull-ups

   P0=0x48;
   P0MDOUT |= 0xB7;                    // enable UTX as push-pull output
   P1MDOUT |= 0xC0;                    // /WR and /RD are push-pull
                                       // AB4 LEDs are push-pull
   P2MDOUT |= 0xff;
   P3MDOUT |= 0xFF;
   P4MDOUT |= 0xFF;
   
   
}

//-----------------------------------------------------------------------------
// EMIF_Init
//-----------------------------------------------------------------------------
//
// Configure the External Memory Interface for both on and off-chip access.
//
void EMIF_Init (void)
{

   EMI0CF = 0x1B;             // non-muxed mode; split mode
                              // with bank select 0x1B, 17??

   EMI0TC = EMIF_TIMING;      // This constant may be modified
                              // according to SYSCLK to meet the
                              // timing requirements for the CP2200

   EMI0CN = 0x10;//BASE_ADDRESS;     // Page of XRAM accessed by EMIF

}

//-----------------------------------------------------------------------------
// SYSCLK_Init
//-----------------------------------------------------------------------------
//
// This routine initializes the system clock.
//
void SYSCLK_Init (void)
{
   int i;

   OSCICN |= 0x03;                     // Configure internal oscillator for
                                       // its maximum frequency
  
   CLKMUL = 0x00;                      // Reset Clock Multiplier and select
                                       // internal oscillator as input source

   CLKMUL |= 0x80;                     // Enable the Clock Multiplier

   for(i = 0; i < 256; i++);           // Delay at least 5us
   
   CLKMUL |= 0xC0;                     // Initialize the Clock Multiplier
   
   while(!(CLKMUL & 0x20));            // Wait for MULRDY => 1
   
   RSTSRC = 0x06;                      // Enable missing clock detector
                                       // and VDD monitor
   
   FLSCL |= 0x10;                      // Set Flash Scale for 48MHz
   
   CLKSEL |= 0x03;                     // Select output of clock multiplier
                                       // as the system clock.

}

//-----------------------------------------------------------------------------
// ether_reset_low
//-----------------------------------------------------------------------------
//
// This routine drives the reset pin of the ethernet controller low.
//
void ether_reset_low()
{

   P1 &= ~0x01;               // Pull reset low

}

//-----------------------------------------------------------------------------
// ether_reset_high
//-----------------------------------------------------------------------------
//
// This routine places the reset pin in High-Z allowing it to be pulled up 
// using the external pull-up resistor.
//
// Additionally, this routine waits for the reset pin to read high before
// exiting.
//
void ether_reset_high (void)
{

   P1 |= 0x01;               // Allow /RST to rise
   while(!(P1 & 0x01));      // Wait for /RST to go high


}
